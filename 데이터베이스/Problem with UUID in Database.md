# Problem with UUID in Database
[1차 출처](https://www.percona.com/blog/2019/11/22/uuids-are-popular-but-bad-for-performance-lets-discuss/)

[2차 출처](https://youtu.be/Y5mWz4vK10A)

## 페이지 교체가 잦아짐
MySQL의 InnoDB는 클러스터 인덱스를 사용한다.

각 행은 '페이지'로 구분되어 있는데, 클러스터 인덱스는 모든 행의 PK를 정렬한 다음 각 행을 그룹화하여 하나의 페이지로 만들어 저장한다.

추후 특정 행에 접근이 필요할 때, MySQL은 '버퍼 풀'이라는 곳에 특정 행이 속한 페이지를 올려둔다. 여기서 버퍼 풀은 메모리 상에 존재하며, 읽기/쓰기 작업은 여기서 진행된다. 만약 버퍼 풀이 가득 차서 교체가 필요한 경우에는 flush하여 변경 사항을 디스크에 저장한다.

PK가 정수인 경우, 삽입 순서에 따라 1씩 증가하므로, 계속 삽입할 경우 버퍼 풀의 페이지 교체는 비교적 자주 일어나지 않는다. 다만 PK가 랜덤 값인 UUID인 경우, 한 번의 삽입이 있을 때마다 무작위의 페이지에 접근이 가능하게 된다. 이는 곧 잦은 페이지 교체를 의미하며 버퍼 풀에는 페이지가 금방 차게 된다. 페이지가 금방 차게 된다는 것은 스래싱이 빨리 발생하게됨을 의미한다.

또한 UUID는 용량을 많이 잡아먹기 때문에 이 또한 페이지 교체에 악영향을 미친다.

이와 관련된 그래프는 `1차 출처`에서 확인할 수 있다.

## 비교 속도가 더 느려짐
정수의 경우 32비트를 비교하면 되지만 UUID는(`char(36)`으로 저장될 시) 각 문자를 하나씩 비교하기때문에 비교 속도가 느려지게 된다. `1차 출처`에서 시험한 결과 정수 비교는 0.96초에 완료되는 반면, UUID는 27초나 걸린다(SQL문과 처리 속도에 따라 추정하자면 1억번 반복한것으로 보인다).

## 해결 방법
`1차 출처`의 글에서는 두 가지 방법을 제시한다. UUID에 임의로 순서를 부여하는 방식과, UUID를 정수에 매핑하는 방법이다. 자세한 내용은 출처 참조.

## Postgres의 경우
Postgres는 클러스터 인덱스를 구성해도 각 행을 PK에 따라 정렬하지 않기 때문에 UUID로 인한 성능 피해가 적을 것으로 예상된다. Postgeres는 각 행을 삽입할 때마다 클러스터링, 즉 정렬을 진행하지 않으며, `CLUSTER table_name` 명령을 통해 명시적으로 지시해야한다. 이를 통해 Postgres가 MySQL보다 삽입 속도면에서 우월하다는 것을 예상할 수 있다.
